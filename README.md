# ИДЗ 4
Кадыкова Татьяна Алексеевна, БПИ213

Вариант 34

Тесты, на которых проверялась работа программ, находятся в папке `test`.
Файлы с названиями `input*.txt` являются входными файлами.
Выходные файлы с названиями `output*.txt` находятся в папках соответствующих программ.
Обязательным для запуска является указание файла `decoder.txt`, в данном проекте он находится
в корне, он использовался для всех входных файлов.

## Задание
И снова пляшущие человечки. Узнав о планах преступников по
шифрованию текстов, Шерлок Холмс предложил лондонской полиции специальную машину для дешифровки сообщений злоумышленников. Реализовать приложение, дешифрующее кодированный текст. В качестве ключа используется известная кодовая таблица, устанавливающая однозначное соответствие между каждой буквой и каким-нибудь числом. Процессом узнавания кода в решении задачи пренебречь. Каждый процесс–дешифровщик декодирует свои кусочки текста, многократно получаемые от менеджера. Распределение фрагментов
текста между процессами–дешифровщиками осуществляется процессом–
менеджером, который передает каждому процессу фрагмент зашифрованного текста,
получает от него результат, передает следующий зашифрованный фрагмент.
Он же собирает из отдельных
фрагментов зашифрованный текст. Количество процессов задается опционально.
Каждый процесс может выполнять свою работу за случайное время.
Сервер — процесс–менеджер. Клиенты — процессы–дешифровщики.


## Компиляция и запуск на оценку 4-5
Компиляция через: 

`gcc server.c -o server`

`gcc client.c -o client`

Запуск программы происходит в разных терминалах через: 

1. `./server <Clients number> <Decoder file> <Input file> <Output file> <Server Port>`.
2. `./client <Server IP> <Echo Port>`.

Многие общие серверные глобальные переменные были вынесены в файл `info.h`, а клиентские в `clientinfo.h`, 
для более удобного пользования, а также некоторые функции.

## Компиляция и запуск на оценку 6-7
Компиляция через:

`gcc server.c -o server`

`gcc client_decoder.c -o decoder`

`gcc client_observer.c -o observer`

Запуск программы происходит в разных терминалах через:

1. `./server <Clients number> <Decoder file> <Input file> <Output file> <Server Port>`.
2. `./decoder <Server IP> <Echo Port>`.
3. `./observer <Server IP> <Echo Port>`.

Многие общие серверные глобальные переменные были вынесены в файл `info.h`, а клиентские в `clientinfo.h`,
для более удобного пользования, а также некоторые функции.

## На 4-5
Код находится в `for45/server.c` и `for45/client.c`.

Клиенты создают UDP сокет и отправляют сообщение серверу о подключении.
После отправки сообщение серверу они получают массив дешифровки от сервера.
Далее дешифровщики работают до тех пор, пока им приходят массивы с целочисленными положительными значениями.
Знаком остановки клиента является отрицательный первый элемент полученного массива, тогда клиенты завершают свою работу.
Полученное сообщение клиент декодирует и отправляет обратно декодированное сообщение через сокет.

Сервер не работает с разделяемой памятью, семафорами и не делится на дочерние процессы. 
Сервер создает UDP сокет, связывает свой адрес с ним, а дальше ждет подключения клиентов - 
получения от них сообщения о подключении. Сервер сохраняет адрес (sockaddr_in) в массив clnt_addrs (для дальшейшей работы) и 
отправляет клиенту массив дешифровки (полученный ранее из указанного в параметрах файла).
После подключения клиентов сервер начинает дешифровку входного файла, отправляет кусок следующему на очереди клиенту.
После загрузки всех клиентов (при наличии работы) работой, сервер ждет обратных сообщений от клиентов. Для каждого полученного
сообщения он сначала идентифицирует от какого клиента оно пришло, и записывает декодированный кусок в нужное место
в общем массиве (сообщения от клиентов могут прийти в другом порядке, не по порядку номера клиента). При получении всех 
ожидаемых сообщений, сервер записывает декодированную часть в выходной файл.


## На 6-7
Код находится в `for67/server.c`, `for67/client_decoder.c` и `for67/client_observer.c`.
Взаимодействие сервера и клиентов-дешифровщиков не изменилось.
Клиент-наблюдатель подключается к серверу аналогично клиенту-дешифровщику, печатает все сообщения, которые ему приходят, 
и прекращает работу, когда приходит сообщение, состоящее только из нулевого символа.
Сервер сохраняет отдельно адрес клиента-наблюдателя.
Сервер отправляет сообщения наблюдателю, и при завершении работы он отправляет сообщение из нулевого символа.
